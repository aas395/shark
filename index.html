<!DOCTYPE html>
<html>
  <head>
    <title>SharkVR</title>
    <meta name="description" content="SharkVR Game">
    <script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-extras/v3.8.4/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.rawgit.com/ngokevin/aframe-physics-components/master/dist/aframe-physics-components.min.js"></script>
    
    <script>
      AFRAME.registerSystem('game', {
        schema: {
          score: {
            type: "number",
            default: 0
          }
        },  // System schema. Parses into `this.data`.
        init: function () {
          // this.el.appendChild('<a-entity physics-body="static-body" mixin="build" geometry="depth: 150; width: 150; height: 140;" position="110 69 1500" material="src: url(https://cdn.glitch.com/b870d9ec-1139-44f9-b462-223e4a2c74e7%2Ftexture.jpg?1490308149272)"></a-entity>')
        },
        tick: function() {
          // this.data.score++;
        }
      });
      
      AFRAME.registerComponent('obstacles-container', {
        init: function () {
          
          var obstacles = [
            {
              "mixin": "build",
            },
            {
              "mixin": "build"
            },
            {
              "mixin": "build"
            },
            {
              "mixin": "build"
            },
            {
              "mixin": "build"
            },
            {
              "mixin": "build"
            }
          ];
          
          for(var i = 0; i < obstacles.length; i++) {
            var currentObstacle = obstacles[i];
            var building = document.createElement('a-entity');
          
            var depth = 40;
            var width = 40;
            var height = 40;
            
            currentObstacle.geometry = "depth:" + depth + "; width:" + width + "; height: " + height + ";";
            
            var signOfX = Math.random() >= 0.5 ? -1 : 1;
            var positionX = Math.floor(Math.random() * 50) * signOfX;
            
            var signOfY = Math.random() >= 0.5 ? -1 : 1;
            var positionY = Math.floor(Math.random() * 50) * signOfY;
            
            var positionZ = -Math.floor(Math.random() * 1000);
            
            currentObstacle.position = positionX + " " + positionY + " " + positionZ;
            
            for(key in currentObstacle) {
              var newAttribute = document.createAttribute(key);
              newAttribute.value = currentObstacle[key];
              building.setAttributeNode(newAttribute);
            }
          
            this.el.appendChild(building);
          }
        },
        tick: function() {
          // this.data.score++;
        }
      });
      
      AFRAME.registerComponent("listener", {
		    schema : 
        {
          forwardFactor : {
            type : "number",
            default : 2
          },
          target: {
            type: 'selector'
          },
          distance: {
            type: 'vec3'
          }
        },
        init: function() {
          var playerEl = document.querySelector('#character');
          var that = this;
          
          playerEl.addEventListener('collide', function (e) {
            var collidedWithEl = e.detail.body.el;
            console.log('collision');
            
            if(collidedWithEl.id == 'cylinder') {
              console.log('Collided with the wall');
              
              var xPosition = e.detail.target.position.x;
              var yPosition = e.detail.target.position.y;
              
              var xDirectionAdjustment = xPosition > 0 ? -1 : 1; 
              var yDirectionAdjustment = yPosition > 0 ? -1 : 1;
              
              document.querySelector('#character').setAttribute('position', {
                  x: xPosition + (5 * xDirectionAdjustment),
                  y: yPosition + (5 * yDirectionAdjustment)
              });
            }
          });
        },
        tick : function() {	
            const targetItem = this.data.target;
            var distance = this.data.distance;
            var targetPosition = targetItem.getAttribute('position');
            const direction = this.el.components.camera.camera.getWorldDirection();

            var currentPosition = {
              x: targetPosition.x + direction.x,
              y: targetPosition.y + direction.y,
              z: targetPosition.z + -this.data.forwardFactor
            };

            this.el.setAttribute('position', currentPosition); 
        }
      });
      
      
      
    //Using the date/time is the only thing I could think to use as a timer
		// Gets the initial time
		var initialTime = new Date().getTime();

		// Update the count down every 1 second
		var x = setInterval(function() {

      // Get todays date and time
      var now = new Date().getTime();

      // Find the distance between now and the initial time
      var distance = now - initialTime;

      // Time calculations for minutes and seconds
      var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      var seconds = Math.floor((distance % (1000 * 60)) / 1000);

      // Display the result in the element with id="demo"
      document.getElementById("time").setAttribute('text', 'value: ' + minutes + "m " + seconds + "s ;");

      // When the player dies or reaches x amount of points 

      if (distance < 0) { 
          //clearInterval(x);		
        }
    }, 1000);
			
		//End of Timer Script
      
   </script>
  </head>
  <body>
 
    <!-- Fog for dimming objects in distance -->
    <a-scene physics="gravity: 0;" canvas fog="type: linear; color: #40a4df; far: 2200; near: 0;">
      <asset>
        <a-mixin id="build" physics-body="static-body" geometry="primitive: box" material="shader: standard; metalness: 0.6; src: url(https://cdn.glitch.com/b870d9ec-1139-44f9-b462-223e4a2c74e7%2Ftexture.jpg?1490308149272)"></a-mixin>
      </asset>
   
      <a-entity static-body id="cylinder" geometry="primitive: cylinder; height: 6000; radius: 100; open-ended: true" position="0 0 1000" rotation="-90 0 0" material="src: url(https://cdn.glitch.com/b870d9ec-1139-44f9-b462-223e4a2c74e7%2Ftexture.jpg?1490308149272); shader: flat; side: double; opacity: 0.8;"></a-entity>
   
      <a-entity obstacles-container>

      </a-entity>
   
      <!-- Camera -->
      <a-entity id="character" position="0 10 500" kinematic-body listener="target: #character" camera universal-controls>
        <a-entity class="timer" geometry="primitive: plane; width: 0.3; height: 0.1;" position="0 0.7 -0.9" rotation="40 0 0" material="shader: flat; opacity: 0.8; transparent: true; src: url(images/health-bar.png)">
          <a-entity id="time"></a-entity>
        </a-entity>
      </a-entity>

      <!-- Lighting and background -->
      <a-sky color="#cccccc"></a-sky>
   
    </a-scene>
    
    
  </body>
  
</html>